**DATASET**

We used two datasets for our visualization. The first dataset is the Billboard Weekly Hot 100 songs per week. Here, for each week, we were given the song, the performer, its rank on the chart, and the number of weeks it has been on the chart in the past. We also used a dataset mapping each song to its spotify audio features, pulled via the Spotify Web API. For each song, we were given the album, genre, and other Spotify derived features such as danceability. We also retrieved extra information such as the album cover images and song preview links through requests to the Spotify Web API. 


**VISUAL ENCODING**

For our visualization, we used a bar chart race, with the relative rank of a song on the Billboard chart as the y-axis and the number of weeks a song was on the Billboard chart as the x-axis. We chose the bar mark to encode the longevity of a song on the chart and the bar’s relative height to encode the song’s popularity. With this, we were able to showcase some trends such as Drake’s dominance in early 2018 or “Old Town Road”’s longevity on the charts. In addition, we used an animation to smoothen the state transitions between weeks and increase engagement with our viewers. Alternatively, we considered using a line chart race but we decided against it because a song’s weeks on the Billboard charts, and accordingly its longevity would be lost. We also figured that the discrete jumps in rank would be difficult to smoothen, and thus would be hard to follow. We encoded the color of each bar using the SongID. Although some bars had the same colors, the labels next to the bars still distinguished them. Finally, in our MVP we let the user choose the speed of the animation. In our final version, however, we removed this feature to reduce clutter and general confusion in the control bar. Instead, we set the speed of the animation ourselves such that transitions could be easily followed while not being too slow. 

**INTERACTIVE ELEMENTS**

For our main interactive element, we used a draggable slider that controls the state of the animation, and a play/stop button that automatically plays and stops the animation. The slider acts as both a progress bar during the animation, and a way for the viewer to select the week that they wanted to jump to. Initially in our MVP, we had a date drop-down selector to let viewers choose exact dates. For our final version, we removed this because the drop down selector was both obtrusive and not user friendly. In particular, when the selector was open, the list was too long and thus blocked the view of the animation. The viewer would also need to click twice, once to open the selector and another to pick a date. Lastly, the selector added unnecessary clutter to the control bar. Instead, we added labels to our slider as well as next and previous week buttons to both give more context on the slider’s approximate weeks, and give finer control for transitioning through these weeks.

We used tooltips that appear when a user’s cursor hovers over a particular bar to show more information about the song associated with that bar. Specifically, tooltips show the song name, artist, album, genre(s), and the album photo. Note that this information is not needed to identify a particular song since the label next to the bar includes the song name and artist. We encoded this extra information behind a tooltip because it provides more context. For example, the tooltip informs the viewer about the song album, enabling the viewer to look up that album and discover more songs that they may enjoy. Tooltips also instruct the user that they can click on the bar to preview the song. Since it is very likely that the viewer hovers over any particular bar, we added this line to ensure that viewers know how to use the song preview player. An alternative design we considered was adding a subset of this extra information onto the bars or the label beside it. We chose against this alternative because the visualization would become too cluttered and take away from the most important elements of the animation. 

Since the last iteration in our MVP, we added a song player to the right of the visualization. The song player contains the album cover, song title, and song player, which are all commonly used elements in most song playing applications. We added the song player to refresh the user’s memory of a particular song and/or discover new songs that they’ve never heard before. For example, while testing, we played the most popular country songs after selecting the Country filter because we had never heard them before. In addition, with the song player, users can play a song while running the main animation which increases user engagement. 

We included genre filters for the most popular song genres: Pop, Rap, Country, and Hip Hop. When a genre filter is selected, only songs with that genre show up in the main bar chart, meaning that they are ranked 1 to 10 relative to each other. These genre filters allow viewers to discover and compare popular artists and songs from a particular set of genres. It also allows viewers to filter based song genres based on personal preference. For example, country song fans who normally wouldn’t see their favorite country songs in the top 10 can with the use of the Country filter. 

**DEVELOPMENT PROCESS**

Most of the code was written together, either through Zoom and VSCode LiveShare, or through sitting next to each other in Victor’s room. Individually, Umarbek implemented the html and css and the slider interactions, while Victor implemented the data cleaning and Spotify Web API calls. 

Initially, getting the bar chart race to work took the most time because we were unfamiliar with how to use D3 join, update, and remove functions for large datasets. Since each of our data points were a distinct object containing the song name, week, and week position, we couldn’t figure out how to link the same songs across different weeks. Without links between the same songs together, we wouldn’t be able to add transitions across weeks. We were able to solve this issue by using songIDs to link the same songs. Overall, we each spent around 10 people hours together trying to implement the bar chart race, even with the help of the D3 Observable notebook on the bar chart race (https://observablehq.com/@d3/bar-chart-race-explained). 

Overall, Umarbek spent 36 hours and Victor spent 33 hours, for a combined total of 69 hours spent on this visualization. 24 of these hours were spent either planning or pair programming together. 
